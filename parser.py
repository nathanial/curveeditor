from las.file import *
from las.headers import *
from util import subdivide


# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class LASParserScanner(runtime.Scanner):
    patterns = [
        ('"\\r"', re.compile('\r')),
        ('"\\r\\n"', re.compile('\r\n')),
        ('"\\n"', re.compile('\n')),
        ('"\\n\\r"', re.compile('\n\r')),
        ('"~A"', re.compile('~A')),
        ('"~C"', re.compile('~C')),
        ('"WRAP."', re.compile('WRAP.')),
        ('":"', re.compile(':')),
        ('"VERS."', re.compile('VERS.')),
        ('"~V"', re.compile('~V')),
        ('"~P"', re.compile('~P')),
        ('"~W"', re.compile('~W')),
        (' ', re.compile(' ')),
        ('#[^\n]*\n', re.compile('#[^\n]*\n')),
        ('MNEMONIC', re.compile('\\w+')),
        ('UNIT', re.compile('[.][^\n:. ]*')),
        ('DESCRIPTION', re.compile(':[^\n:]*')),
        ('STRING', re.compile('.*')),
        ('LINE', re.compile('[^\n]*')),
        ('DELIMITER_FREE_STRING', re.compile('[^\n:.]*')),
        ('COLON_FREE_STRING', re.compile('[^\n:]*')),
        ('NUM', re.compile('-?[0-9]+')),
        ('FLOAT', re.compile('-?[0-9]+[.][0-9]+')),
        ('EMPTY', re.compile('')),
        ('DATA', re.compile('[^\n]*(?= :[^\n:]*)')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{' ':None,'#[^\n]*\n':None,},str,*args,**kw)

class LASParser(runtime.Parser):
    Context = runtime.Context
    def las_file(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'las_file', [])
        version_header = self.version_header(_context)
        well_header = self.well_header(_context)
        curve_header = self.curve_header(_context)
        parameter_header = self.parameter_header(_context)
        data_rows = self.data_rows(_context)
        return LasFile(version_header, well_header, curve_header, parameter_header, subdivide(data_rows, len(curve_header.descriptors)))

    def well_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'well_header', [])
        while self._peek('"~W"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"VERS."', '"WRAP."', '"~P"', '"~V"', '"~C"', '"~A"', 'MNEMONIC', 'NUM', 'FLOAT', context=_context) in ['"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~W"', context=_context)
        LINE = self._scan('LINE', context=_context)
        end_line = self.end_line(_context)
        descriptors = []
        while self._peek('MNEMONIC', '"VERS."', '"WRAP."', '"~C"', '"~W"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"~P"', '"~V"', '"~A"', 'NUM', 'FLOAT', context=_context) == 'MNEMONIC':
            descriptor = self.descriptor(_context)
            descriptors.append(descriptor)
            end_line = self.end_line(_context)
        return WellHeader(descriptors)

    def parameter_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'parameter_header', [])
        while self._peek('"~P"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"VERS."', '"WRAP."', '"~W"', '"~V"', '"~C"', '"~A"', 'MNEMONIC', 'NUM', 'FLOAT', context=_context) in ['"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~P"', context=_context)
        LINE = self._scan('LINE', context=_context)
        end_line = self.end_line(_context)
        descriptors = []
        while self._peek('MNEMONIC', '"VERS."', '"WRAP."', '"~A"', '"~W"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"~P"', '"~V"', '"~C"', 'NUM', 'FLOAT', context=_context) == 'MNEMONIC':
            descriptor = self.descriptor(_context)
            descriptors.append(descriptor)
            end_line = self.end_line(_context)
        return ParameterHeader(descriptors)

    def version_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'version_header', [])
        while self._peek('"~V"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"VERS."', '"WRAP."', '"~W"', '"~P"', '"~C"', '"~A"', 'MNEMONIC', 'NUM', 'FLOAT', context=_context) in ['"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~V"', context=_context)
        LINE = self._scan('LINE', context=_context)
        end_line = self.end_line(_context)
        self._scan('"VERS."', context=_context)
        number = self.number(_context)
        self._scan('":"', context=_context)
        vers = number
        end_line = self.end_line(_context)
        self._scan('"WRAP."', context=_context)
        COLON_FREE_STRING = self._scan('COLON_FREE_STRING', context=_context)
        self._scan('":"', context=_context)
        wrap = COLON_FREE_STRING
        end_line = self.end_line(_context)
        return VersionHeader(vers,wrap)

    def curve_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'curve_header', [])
        while self._peek('"~C"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"VERS."', '"WRAP."', '"~W"', '"~P"', '"~V"', '"~A"', 'MNEMONIC', 'NUM', 'FLOAT', context=_context) in ['"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~C"', context=_context)
        LINE = self._scan('LINE', context=_context)
        end_line = self.end_line(_context)
        descriptors = []
        while self._peek('"VERS."', '"WRAP."', 'MNEMONIC', '"~P"', '"~W"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"~V"', '"~C"', '"~A"', 'NUM', 'FLOAT', context=_context) == 'MNEMONIC':
            descriptor = self.descriptor(_context)
            descriptors.append(descriptor)
            end_line = self.end_line(_context)
        return CurveHeader(descriptors)

    def descriptor(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'descriptor', [])
        MNEMONIC = self._scan('MNEMONIC', context=_context)
        UNIT = self._scan('UNIT', context=_context)
        DATA = self._scan('DATA', context=_context)
        DESCRIPTION = self._scan('DESCRIPTION', context=_context)
        return Descriptor(MNEMONIC, UNIT[1:], DATA, DESCRIPTION[1:].strip())

    def data_rows(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'data_rows', [])
        while self._peek('"~A"', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', '"VERS."', '"WRAP."', '"~W"', '"~P"', '"~V"', '"~C"', 'MNEMONIC', 'NUM', 'FLOAT', context=_context) in ['"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~A"', context=_context)
        LINE = self._scan('LINE', context=_context)
        end_line = self.end_line(_context)
        data = []
        while self._peek('"VERS."', '"WRAP."', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', 'NUM', 'FLOAT', 'MNEMONIC', '"~W"', '"~P"', '"~V"', '"~C"', '"~A"', context=_context) in ['NUM', 'FLOAT']:
            row = self.row(_context)
            data.extend(row)
            if self._peek('"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', '"VERS."', '"WRAP."', 'MNEMONIC', 'EMPTY', 'NUM', 'FLOAT', '"~W"', '"~P"', '"~V"', '"~C"', '"~A"', context=_context) in ['"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"']:
                end_line = self.end_line(_context)
        space = self.space(_context)
        return data

    def row(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'row', [])
        columns = []
        while 1:
            number = self.number(_context)
            columns.append(number)
            if self._peek('NUM', 'FLOAT', '"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', '"VERS."', '"WRAP."', 'MNEMONIC', 'EMPTY', '"~W"', '"~P"', '"~V"', '"~C"', '"~A"', context=_context) not in ['NUM', 'FLOAT']: break
        return columns

    def number(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'number', [])
        _token = self._peek('NUM', 'FLOAT', context=_context)
        if _token == 'NUM':
            NUM = self._scan('NUM', context=_context)
            return eval(NUM)
        else: # == 'FLOAT'
            FLOAT = self._scan('FLOAT', context=_context)
            return eval(FLOAT)

    def end_line(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'end_line', [])
        _token = self._peek('"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', context=_context)
        if _token == '"\\n\\r"':
            self._scan('"\\n\\r"', context=_context)
        elif _token == '"\\n"':
            self._scan('"\\n"', context=_context)
        elif _token == '"\\r\\n"':
            self._scan('"\\r\\n"', context=_context)
        else: # == '"\\r"'
            self._scan('"\\r"', context=_context)

    def space(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'space', [])
        _token = self._peek('"\\n\\r"', '"\\n"', '"\\r\\n"', '"\\r"', 'EMPTY', context=_context)
        if _token != 'EMPTY':
            end_line = self.end_line(_context)
        else: # == 'EMPTY'
            EMPTY = self._scan('EMPTY', context=_context)


def parse(rule, text):
    P = LASParser(LASParserScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
