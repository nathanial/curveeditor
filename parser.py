from las.file import *
from las.headers import *
from util import subdivide


# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class LASParserScanner(runtime.Scanner):
    patterns = [
        ('"~A"', re.compile('~A')),
        ('"."', re.compile('.')),
        ('"~C"', re.compile('~C')),
        ('"WRAP."', re.compile('WRAP.')),
        ('":"', re.compile(':')),
        ('"VERS."', re.compile('VERS.')),
        ('"~V"', re.compile('~V')),
        ('"~P"', re.compile('~P')),
        ('"~W"', re.compile('~W')),
        ('( |[#][^\n\r]*)', re.compile('( |[#][^\n\r]*)')),
        ('ENDLINE', re.compile('(\n\r)|\n|(\r\n)|\r')),
        ('MNEMONIC', re.compile('[^.]+')),
        ('UNIT', re.compile('[^ ]+')),
        ('DESCRIPTION', re.compile('[^\n\r:]+')),
        ('STRING', re.compile('.*')),
        ('LINE', re.compile('[^\n\r]*')),
        ('DELIMITER_FREE_STRING', re.compile('[^\n\r:.]*')),
        ('COLON_FREE_STRING', re.compile('[^\n:]*')),
        ('NUM', re.compile('-?[0-9]+')),
        ('FLOAT', re.compile('-?[0-9]+[.][0-9]+')),
        ('EMPTY', re.compile('')),
        ('DATA', re.compile('[^\n\r]+(?= :[^\n\r:]*)')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'( |[#][^\n\r]*)':None,},str,*args,**kw)

class LASParser(runtime.Parser):
    Context = runtime.Context
    def las_file(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'las_file', [])
        version_header = self.version_header(_context)
        well_header = self.well_header(_context)
        curve_header = self.curve_header(_context)
        parameter_header = self.parameter_header(_context)
        data_rows = self.data_rows(_context)
        return LasFile(version_header, well_header, curve_header, parameter_header, subdivide(data_rows, len(curve_header.descriptors)))

    def well_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'well_header', [])
        while self._peek('"~W"', 'ENDLINE', 'EMPTY', '"~P"', '"~V"', '"~C"', '"~A"', context=_context) in ['ENDLINE', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~W"', context=_context)
        LINE = self._scan('LINE', context=_context)
        ENDLINE = self._scan('ENDLINE', context=_context)
        descriptors = []
        while self._peek('MNEMONIC', '"~C"', 'ENDLINE', 'EMPTY', '"~W"', '"~P"', '"~V"', '"~A"', context=_context) == 'MNEMONIC':
            descriptor = self.descriptor(_context)
            descriptors.append(descriptor)
            ENDLINE = self._scan('ENDLINE', context=_context)
        return WellHeader(descriptors)

    def parameter_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'parameter_header', [])
        while self._peek('"~P"', 'ENDLINE', 'EMPTY', '"~W"', '"~V"', '"~C"', '"~A"', context=_context) in ['ENDLINE', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~P"', context=_context)
        LINE = self._scan('LINE', context=_context)
        ENDLINE = self._scan('ENDLINE', context=_context)
        descriptors = []
        while self._peek('MNEMONIC', '"~A"', 'ENDLINE', 'EMPTY', '"~W"', '"~P"', '"~V"', '"~C"', context=_context) == 'MNEMONIC':
            descriptor = self.descriptor(_context)
            descriptors.append(descriptor)
            ENDLINE = self._scan('ENDLINE', context=_context)
        return ParameterHeader(descriptors)

    def version_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'version_header', [])
        while self._peek('"~V"', 'ENDLINE', 'EMPTY', '"~W"', '"~P"', '"~C"', '"~A"', context=_context) in ['ENDLINE', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~V"', context=_context)
        LINE = self._scan('LINE', context=_context)
        ENDLINE = self._scan('ENDLINE', context=_context)
        self._scan('"VERS."', context=_context)
        number = self.number(_context)
        self._scan('":"', context=_context)
        vers = number
        ENDLINE = self._scan('ENDLINE', context=_context)
        self._scan('"WRAP."', context=_context)
        COLON_FREE_STRING = self._scan('COLON_FREE_STRING', context=_context)
        self._scan('":"', context=_context)
        wrap = COLON_FREE_STRING
        ENDLINE = self._scan('ENDLINE', context=_context)
        return VersionHeader(vers,wrap)

    def curve_header(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'curve_header', [])
        while self._peek('"~C"', 'ENDLINE', 'EMPTY', '"~W"', '"~P"', '"~V"', '"~A"', context=_context) in ['ENDLINE', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~C"', context=_context)
        LINE = self._scan('LINE', context=_context)
        ENDLINE = self._scan('ENDLINE', context=_context)
        descriptors = []
        while self._peek('MNEMONIC', '"~P"', 'ENDLINE', 'EMPTY', '"~W"', '"~V"', '"~C"', '"~A"', context=_context) == 'MNEMONIC':
            descriptor = self.descriptor(_context)
            descriptors.append(descriptor)
            ENDLINE = self._scan('ENDLINE', context=_context)
        return CurveHeader(descriptors)

    def descriptor(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'descriptor', [])
        MNEMONIC = self._scan('MNEMONIC', context=_context)
        self._scan('"."', context=_context)
        unit = None
        data = None
        UNIT = self._scan('UNIT', context=_context)
        unit = UNIT
        if self._peek('DATA', '":"', context=_context) == 'DATA':
            DATA = self._scan('DATA', context=_context)
            data = DATA
        self._scan('":"', context=_context)
        DESCRIPTION = self._scan('DESCRIPTION', context=_context)
        print "pmnemonic = %s " % MNEMONIC,
        print "punit = %s " % unit,
        print "pdata = %s " % data,
        print "pdescription = %s" % DESCRIPTION
        return Descriptor(MNEMONIC, unit, data, DESCRIPTION.strip())

    def data_rows(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'data_rows', [])
        while self._peek('"~A"', 'ENDLINE', 'EMPTY', '"~W"', '"~P"', '"~V"', '"~C"', context=_context) in ['ENDLINE', 'EMPTY']:
            space = self.space(_context)
        self._scan('"~A"', context=_context)
        LINE = self._scan('LINE', context=_context)
        ENDLINE = self._scan('ENDLINE', context=_context)
        data = []
        while self._peek('ENDLINE', 'EMPTY', 'NUM', 'FLOAT', context=_context) in ['NUM', 'FLOAT']:
            number = self.number(_context)
            data.append(number)
            if self._peek('ENDLINE', 'NUM', 'FLOAT', 'EMPTY', context=_context) == 'ENDLINE':
                ENDLINE = self._scan('ENDLINE', context=_context)
        space = self.space(_context)
        return data

    def number(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'number', [])
        _token = self._peek('NUM', 'FLOAT', context=_context)
        if _token == 'NUM':
            NUM = self._scan('NUM', context=_context)
            return eval(NUM)
        else: # == 'FLOAT'
            FLOAT = self._scan('FLOAT', context=_context)
            return eval(FLOAT)

    def space(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'space', [])
        _token = self._peek('ENDLINE', 'EMPTY', context=_context)
        if _token == 'ENDLINE':
            ENDLINE = self._scan('ENDLINE', context=_context)
        else: # == 'EMPTY'
            EMPTY = self._scan('EMPTY', context=_context)


def parse(rule, text):
    P = LASParser(LASParserScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
